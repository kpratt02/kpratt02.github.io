{"title":"Zilch and simulations","markdown":{"yaml":{"title":"Zilch and simulations"},"headingText":"Zilch!","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(fig.width = 6, fig.height = 3.6, fig.align = \"center\",\n                      fig.retina = 3, collapse = TRUE)\nlibrary(tidyverse)\nlibrary(kableExtra)\nlibrary(scales)\n\noptions(\"digits\" = 4, \"width\" = 150)\n\nset.seed(1234)\n```\n\n```{css, echo=FALSE}\n.dice {\n  width: auto;\n  height: 30px;\n  display: inline;\n}\n```\n\n\n### Rules\n\nRoll six dice. You must keep at least one scoring die every roll. You must get at least 500 points before stopping and keeping the total. If you do not get 500 points, you get zilch (0) that round and the next person rolls.\n\nAfter reaching 500 points, you can either stop, write down, and keep your score or continue to roll. As long as you can keep at least one scoring die, you can continue to roll and accumulate points. If you do not get a scoring combination in a roll, you lose all those points.\n\nIf you score with all six dice, you can pick them all up and continue rolling with them.\n\nWhoever reaches 10,000 points first wins.\n\n### Point system\n\n```{r scoring-table, echo=FALSE}\ndice_1 <- '<img src=\"/files/img/dice/1.svg\" class=\"dice\" alt=\"1\">'\ndice_2 <- '<img src=\"/files/img/dice/2.svg\" class=\"dice\" alt=\"2\">'\ndice_3 <- '<img src=\"/files/img/dice/3.svg\" class=\"dice\" alt=\"3\">'\ndice_4 <- '<img src=\"/files/img/dice/4.svg\" class=\"dice\" alt=\"4\">'\ndice_5 <- '<img src=\"/files/img/dice/5.svg\" class=\"dice\" alt=\"5\">'\ndice_6 <- '<img src=\"/files/img/dice/6.svg\" class=\"dice\" alt=\"6\">'\n\npoints <- tribble(\n  ~Group, ~Roll, ~Points,\n  \"Single dice\", dice_1, 100,\n  \"Single dice\", dice_5, 50,\n  \"Three of a kind (number × 100)\", paste(rep(dice_2, 3), collapse = \" \"), 200,\n  \"Three of a kind (number × 100)\", paste(rep(dice_3, 3), collapse = \" \"), 300,\n  \"Three of a kind (number × 100)\", paste(rep(dice_4, 3), collapse = \" \"), 400,\n  \"Three of a kind (number × 100)\", paste(rep(dice_5, 3), collapse = \" \"), 500,\n  \"Three of a kind (number × 100)\", paste(rep(dice_6, 3), collapse = \" \"), 600,\n  \"Special rolls\", paste(rep(dice_1, 3), collapse = \" \"), 1000,\n  \"Special rolls\", paste(rep(dice_1, 4), collapse = \" \"), 2000,\n  \"Special rolls\", paste(\"Any three pairs<br>e.g., \", paste(dice_2, dice_2, dice_3, dice_3, dice_6, dice_6, collapse = \" \")), 1000,\n  \"Special rolls\", paste(\"5-die straight<br>\", paste(dice_1, dice_2, dice_3, dice_4, dice_5, collapse = \" \"), \" or<br>\", paste(dice_2, dice_3, dice_4, dice_5, dice_6, collapse = \" \")), 1750\n) \n\npoints %>% \n  mutate(Points = comma(Points)) %>% \n  select(-Group) %>% \n  kbl(escape = FALSE, align = c(\"l\", \"r\"),\n      table.attr = \"style='width:100%;'\") %>% \n  pack_rows(index = table(fct_inorder(points$Group))) %>% \n  kable_styling(bootstrap_options = \"none\", position = \"center\")\n```\n\n\n## Probability with math\n\nYou can use probability math to calculate the chance of rolling at least a 1 or a 5 (so that you score something and can roll again). If you're only rolling 1 die, the chance of rolling a 1 or a 5 is $\\frac{2}{6}$, or $\\frac{1}{3}$. When you start thinking about 2 dice, though, the math gets a little trickier because you care about rolling *at least* a 1 or 5, and there's a chance you could roll both. So instead, we can calculate the probability of *not* rolling a 1 or a 5 and then subtract that from 1.\n\nWith 2 dice, the probability of *not* rolling a 1 or a 5 is $\\frac{4}{6}$ or $\\frac{2}{3}$ for each die. To calculate the joint probability, we can multiply each die's probability:\n\n$$\n\\begin{aligned}\n1 - (\\frac{2}{3} \\times \\frac{2}{3}) &= \\\\\n1 - \\frac{4}{9} &= 0.5\\overline{55}\n\\end{aligned}\n$$\n\nThat means there's a 55% chance of rolling at least a 1 or a 5 when rolling 2 dice. This approach scales up to any number of dice—multiply that $\\frac{2}{3}$ for each die included. For instance, here's 4 dice:\n\n$$\n\\begin{aligned}\n1 - (\\frac{2}{3} \\times \\frac{2}{3} \\times \\frac{2}{3} \\times \\frac{2}{3}) &= \\\\\n1 - \\frac{16}{81} &= 0.80\n\\end{aligned}\n$$\n\nWe can generalize this by using exponents, where $n$ is the number of dice you're rolling:\n\n$$\n1 - \\frac{2^n}{3^n}\\quad \\text{ or }\\quad 1 - \\left(\\frac{2}{3}\\right)^n\n$$\n\n## Probabilty with math and computers\n\nDoing that math by hand gets tedious, so we can put it in an R function and have R do the math for us.\n\n```{r}\nprob_1_or_5 <- function(n) {\n  1 - (2/3)^n\n}\n\n# 1 die\nprob_1_or_5(1)\n\n# 5 dice\nprob_1_or_5(5)\n\n# 6 dice\nprob_1_or_5(6)\n```\n\n## Probability with computers only\n\nInstead of figuring out the math behind the probability of getting at least a 1 or a 5, we can simulate a bunch of dice rolls and brute force our way to the answer. Here's the general process:\n\n1. Roll 6 dice 100,000 times (or whatever number you want)\n2. Count how many times a 1 or a 5 appears in a roll\n3. Divide that count by 100,000. That's the probability.\n\nProbably the most intiuitive (though not necessarily computationally efficient) way to do with with R is to use [a *for loop*](https://r4ds.had.co.nz/iteration.html#for-loops). In R, a `for` loop will will repeat some chunk of repeatedly until some condition is met, and that condition is generally tracked with an index variable that is specific to the inside of the loop. For instance, this loop uses an index variable named `i`. It will set `i` to 1 the first time it runs the loop and then do whatever's inside (`print(...)` in this case). When it finishes the inside code, it'll bump `i` up to the next number (2 here) and run the inside code again, and again, and again until it reaches the end of the index range (4 here):\n\n```{r loop-example}\nfor (i in 1:4) {\n  print(paste(\"Loop number\", i))\n}\n```\n\nTo make this work with our dice simulation, we need to add one more component. We want to store the results of each loop run in a variable that we can use later. The most efficient way to do this is to create an empty variable first that has enough slots in it to contain the output, then add to that variable while going through the loop:\n\n```{r loop-example-slot}\n# This is \"logical\" because it's only going to hold TRUE and FALSE values. If we\n# wanted to put numbers in it, we'd need to use \"double\"; if we wanted to put\n# text in it, we'd need to use \"character\"\noutput <- vector(\"logical\", 4)\n\nfor (i in 1:4) {\n  # Check if i is 3 and store the result in the ith slot\n  output[[i]] <- i == 3\n}\n\noutput\n```\n\nLet's build a loop now that rolls 6 dice, checks for a 1 or a 5, and stores the result. We'll use 100,000 times for fun.\n\n```{r}\n# Create empty variable with enough slots\nhas_1_or_5 <- vector(\"logical\", 100000)\n\n# Roll a bunch of dice a bunch of times\nfor (i in 1:100000) {\n  # Roll some dice\n  rolled_dice <- sample(1:6, 6, replace = TRUE)\n  \n  # Check if there's a 1 or a 5 in there\n  did_it_happen <- 1 %in% rolled_dice | 5 %in% rolled_dice\n  \n  # Store the result  \n  has_1_or_5[i] <- did_it_happen\n}\n\n# Find the proportion of TRUEs\nsum(has_1_or_5) / 100000\n```\n\nOut of the 100,000 rolls, `r comma(sum(has_1_or_5))` of them had a 1 or a 5 in them, meaning that there's a `r percent(sum(has_1_or_5) / 100000, accuracy = 0.01)` chance of scoring *something* on an initial roll in Zilch.\n\nHow does that compare to the official math?\n\n$$\n1 - \\left( \\frac{2}{3} \\right)^6\n$$\n\n```{r}\nprob_1_or_5(6)\n```\n\nIt's basically the same! But we found the answer without doing any actual probability math, which is neat.\n\nWe can generalize this simulation a little more by not hardcoding some of the parameters. We can make it so both the number of dice to roll and the number of simulations are adjustable by sticking this in a function. For example, here's 4 dice 50,000 times:\n\n```{r}\nsimulate_zilch <- function(n_dice, n_sims) {\n  # Create empty variable with enough slots\n  has_1_or_5 <- vector(\"logical\", n_sims)\n  \n  # Roll a bunch of dice a bunch of times\n  for (i in 1:n_sims) {\n    # Roll some dice\n    rolled_dice <- sample(1:6, n_dice, replace = TRUE)\n    \n    # Check if there's a 1 or a 5 in there\n    did_it_happen <- 1 %in% rolled_dice | 5 %in% rolled_dice\n    \n    # Store the result  \n    has_1_or_5[i] <- did_it_happen\n  }\n  \n  # Find the proportion of TRUEs\n  sum(has_1_or_5) / n_sims\n}\n\nsimulate_zilch(n_dice = 4, n_sims = 50000)\n```\n\n\n## Why even do this?\n\nBut we know the probability equation for getting at least a 1 or a 5, so why go through the hassle of making the computer roll millions of dice? Because we're not actually calculating the true probability of scoring every valid scoring combination! \n\nIn Zilch, you can score with at least a 1 or a 5, but you can also score with three-of-a-kind or three pairs or a 5-die straight. We could calculate the probability of rolling those and combine them with the probability of a 1 or a 5, but the formal equation will get really hairy and complicated. So instead, we can simulate.\n\n```{r}\nsimulate_zilch_full <- function(n_dice, n_sims) {\n  # Create empty variable with enough slots\n  did_something_score <- vector(\"logical\", n_sims)\n  \n  # Roll a bunch of dice a bunch of times\n  for (i in 1:n_sims) {\n    # Roll some dice\n    rolled_dice <- sample(1:6, n_dice, replace = TRUE)\n\n    # Check for 3 pairs separately since it's a complicated process\n    # If there are three different numbers...\n    if (length(table(rolled_dice)) == 3) {\n      # ...check if there are 3 pairs\n      three_pairs <- all(table(rolled_dice) == c(2, 2, 2))\n    } else {\n      three_pairs <- FALSE\n    }\n    \n    # Check if there's a scoring combination in there\n    did_it_happen <- 1 %in% rolled_dice |  # A 1\n      5 %in% rolled_dice |  # A 5\n      all(1:5 %in% rolled_dice) |  # A 1-5 straight\n      all(2:6 %in% rolled_dice) |  # A 2-6 straight\n      max(table(rolled_dice)) >= 3 |  # At least 3 of one number\n      three_pairs  # 3 pairs\n\n    # Store the result\n    did_something_score[i] <- did_it_happen\n  }\n  \n  # Find the proportion of TRUEs\n  sum(did_something_score) / n_sims\n}\n\nsix_dice <- simulate_zilch_full(6, 50000)\n```\n\nPhew! Now that we account for every possible scoring combination, there's a `r percent(six_dice, accuracy = 0.01)` chance of scoring *something* when rolling 6 dice. That's really high!\n\nFor fun, let's look at how that probability changes as the number of dice you roll decreases:\n\n```{r full-simluation, cache=TRUE}\nlibrary(tidyverse)\n\n# hoooo boy this is slow\nnumber_of_dice <- tibble(n_dice = 6:1) %>% \n  mutate(prob = map_dbl(n_dice, ~simulate_zilch_full(., 50000)))\n```\n\n```{r show-results}\nggplot(number_of_dice, aes(x = fct_rev(factor(n_dice)), y = prob)) +\n  geom_col() +\n  scale_y_continuous(labels = percent_format(accuracy = 1)) +\n  labs(x = \"Number of dice rolled\", y = \"Probability of scoring something\",\n       caption = \"Results over 50,000 simulations per count of dice\") +\n  theme_minimal()\n```\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(fig.width = 6, fig.height = 3.6, fig.align = \"center\",\n                      fig.retina = 3, collapse = TRUE)\nlibrary(tidyverse)\nlibrary(kableExtra)\nlibrary(scales)\n\noptions(\"digits\" = 4, \"width\" = 150)\n\nset.seed(1234)\n```\n\n```{css, echo=FALSE}\n.dice {\n  width: auto;\n  height: 30px;\n  display: inline;\n}\n```\n\n## Zilch!\n\n### Rules\n\nRoll six dice. You must keep at least one scoring die every roll. You must get at least 500 points before stopping and keeping the total. If you do not get 500 points, you get zilch (0) that round and the next person rolls.\n\nAfter reaching 500 points, you can either stop, write down, and keep your score or continue to roll. As long as you can keep at least one scoring die, you can continue to roll and accumulate points. If you do not get a scoring combination in a roll, you lose all those points.\n\nIf you score with all six dice, you can pick them all up and continue rolling with them.\n\nWhoever reaches 10,000 points first wins.\n\n### Point system\n\n```{r scoring-table, echo=FALSE}\ndice_1 <- '<img src=\"/files/img/dice/1.svg\" class=\"dice\" alt=\"1\">'\ndice_2 <- '<img src=\"/files/img/dice/2.svg\" class=\"dice\" alt=\"2\">'\ndice_3 <- '<img src=\"/files/img/dice/3.svg\" class=\"dice\" alt=\"3\">'\ndice_4 <- '<img src=\"/files/img/dice/4.svg\" class=\"dice\" alt=\"4\">'\ndice_5 <- '<img src=\"/files/img/dice/5.svg\" class=\"dice\" alt=\"5\">'\ndice_6 <- '<img src=\"/files/img/dice/6.svg\" class=\"dice\" alt=\"6\">'\n\npoints <- tribble(\n  ~Group, ~Roll, ~Points,\n  \"Single dice\", dice_1, 100,\n  \"Single dice\", dice_5, 50,\n  \"Three of a kind (number × 100)\", paste(rep(dice_2, 3), collapse = \" \"), 200,\n  \"Three of a kind (number × 100)\", paste(rep(dice_3, 3), collapse = \" \"), 300,\n  \"Three of a kind (number × 100)\", paste(rep(dice_4, 3), collapse = \" \"), 400,\n  \"Three of a kind (number × 100)\", paste(rep(dice_5, 3), collapse = \" \"), 500,\n  \"Three of a kind (number × 100)\", paste(rep(dice_6, 3), collapse = \" \"), 600,\n  \"Special rolls\", paste(rep(dice_1, 3), collapse = \" \"), 1000,\n  \"Special rolls\", paste(rep(dice_1, 4), collapse = \" \"), 2000,\n  \"Special rolls\", paste(\"Any three pairs<br>e.g., \", paste(dice_2, dice_2, dice_3, dice_3, dice_6, dice_6, collapse = \" \")), 1000,\n  \"Special rolls\", paste(\"5-die straight<br>\", paste(dice_1, dice_2, dice_3, dice_4, dice_5, collapse = \" \"), \" or<br>\", paste(dice_2, dice_3, dice_4, dice_5, dice_6, collapse = \" \")), 1750\n) \n\npoints %>% \n  mutate(Points = comma(Points)) %>% \n  select(-Group) %>% \n  kbl(escape = FALSE, align = c(\"l\", \"r\"),\n      table.attr = \"style='width:100%;'\") %>% \n  pack_rows(index = table(fct_inorder(points$Group))) %>% \n  kable_styling(bootstrap_options = \"none\", position = \"center\")\n```\n\n\n## Probability with math\n\nYou can use probability math to calculate the chance of rolling at least a 1 or a 5 (so that you score something and can roll again). If you're only rolling 1 die, the chance of rolling a 1 or a 5 is $\\frac{2}{6}$, or $\\frac{1}{3}$. When you start thinking about 2 dice, though, the math gets a little trickier because you care about rolling *at least* a 1 or 5, and there's a chance you could roll both. So instead, we can calculate the probability of *not* rolling a 1 or a 5 and then subtract that from 1.\n\nWith 2 dice, the probability of *not* rolling a 1 or a 5 is $\\frac{4}{6}$ or $\\frac{2}{3}$ for each die. To calculate the joint probability, we can multiply each die's probability:\n\n$$\n\\begin{aligned}\n1 - (\\frac{2}{3} \\times \\frac{2}{3}) &= \\\\\n1 - \\frac{4}{9} &= 0.5\\overline{55}\n\\end{aligned}\n$$\n\nThat means there's a 55% chance of rolling at least a 1 or a 5 when rolling 2 dice. This approach scales up to any number of dice—multiply that $\\frac{2}{3}$ for each die included. For instance, here's 4 dice:\n\n$$\n\\begin{aligned}\n1 - (\\frac{2}{3} \\times \\frac{2}{3} \\times \\frac{2}{3} \\times \\frac{2}{3}) &= \\\\\n1 - \\frac{16}{81} &= 0.80\n\\end{aligned}\n$$\n\nWe can generalize this by using exponents, where $n$ is the number of dice you're rolling:\n\n$$\n1 - \\frac{2^n}{3^n}\\quad \\text{ or }\\quad 1 - \\left(\\frac{2}{3}\\right)^n\n$$\n\n## Probabilty with math and computers\n\nDoing that math by hand gets tedious, so we can put it in an R function and have R do the math for us.\n\n```{r}\nprob_1_or_5 <- function(n) {\n  1 - (2/3)^n\n}\n\n# 1 die\nprob_1_or_5(1)\n\n# 5 dice\nprob_1_or_5(5)\n\n# 6 dice\nprob_1_or_5(6)\n```\n\n## Probability with computers only\n\nInstead of figuring out the math behind the probability of getting at least a 1 or a 5, we can simulate a bunch of dice rolls and brute force our way to the answer. Here's the general process:\n\n1. Roll 6 dice 100,000 times (or whatever number you want)\n2. Count how many times a 1 or a 5 appears in a roll\n3. Divide that count by 100,000. That's the probability.\n\nProbably the most intiuitive (though not necessarily computationally efficient) way to do with with R is to use [a *for loop*](https://r4ds.had.co.nz/iteration.html#for-loops). In R, a `for` loop will will repeat some chunk of repeatedly until some condition is met, and that condition is generally tracked with an index variable that is specific to the inside of the loop. For instance, this loop uses an index variable named `i`. It will set `i` to 1 the first time it runs the loop and then do whatever's inside (`print(...)` in this case). When it finishes the inside code, it'll bump `i` up to the next number (2 here) and run the inside code again, and again, and again until it reaches the end of the index range (4 here):\n\n```{r loop-example}\nfor (i in 1:4) {\n  print(paste(\"Loop number\", i))\n}\n```\n\nTo make this work with our dice simulation, we need to add one more component. We want to store the results of each loop run in a variable that we can use later. The most efficient way to do this is to create an empty variable first that has enough slots in it to contain the output, then add to that variable while going through the loop:\n\n```{r loop-example-slot}\n# This is \"logical\" because it's only going to hold TRUE and FALSE values. If we\n# wanted to put numbers in it, we'd need to use \"double\"; if we wanted to put\n# text in it, we'd need to use \"character\"\noutput <- vector(\"logical\", 4)\n\nfor (i in 1:4) {\n  # Check if i is 3 and store the result in the ith slot\n  output[[i]] <- i == 3\n}\n\noutput\n```\n\nLet's build a loop now that rolls 6 dice, checks for a 1 or a 5, and stores the result. We'll use 100,000 times for fun.\n\n```{r}\n# Create empty variable with enough slots\nhas_1_or_5 <- vector(\"logical\", 100000)\n\n# Roll a bunch of dice a bunch of times\nfor (i in 1:100000) {\n  # Roll some dice\n  rolled_dice <- sample(1:6, 6, replace = TRUE)\n  \n  # Check if there's a 1 or a 5 in there\n  did_it_happen <- 1 %in% rolled_dice | 5 %in% rolled_dice\n  \n  # Store the result  \n  has_1_or_5[i] <- did_it_happen\n}\n\n# Find the proportion of TRUEs\nsum(has_1_or_5) / 100000\n```\n\nOut of the 100,000 rolls, `r comma(sum(has_1_or_5))` of them had a 1 or a 5 in them, meaning that there's a `r percent(sum(has_1_or_5) / 100000, accuracy = 0.01)` chance of scoring *something* on an initial roll in Zilch.\n\nHow does that compare to the official math?\n\n$$\n1 - \\left( \\frac{2}{3} \\right)^6\n$$\n\n```{r}\nprob_1_or_5(6)\n```\n\nIt's basically the same! But we found the answer without doing any actual probability math, which is neat.\n\nWe can generalize this simulation a little more by not hardcoding some of the parameters. We can make it so both the number of dice to roll and the number of simulations are adjustable by sticking this in a function. For example, here's 4 dice 50,000 times:\n\n```{r}\nsimulate_zilch <- function(n_dice, n_sims) {\n  # Create empty variable with enough slots\n  has_1_or_5 <- vector(\"logical\", n_sims)\n  \n  # Roll a bunch of dice a bunch of times\n  for (i in 1:n_sims) {\n    # Roll some dice\n    rolled_dice <- sample(1:6, n_dice, replace = TRUE)\n    \n    # Check if there's a 1 or a 5 in there\n    did_it_happen <- 1 %in% rolled_dice | 5 %in% rolled_dice\n    \n    # Store the result  \n    has_1_or_5[i] <- did_it_happen\n  }\n  \n  # Find the proportion of TRUEs\n  sum(has_1_or_5) / n_sims\n}\n\nsimulate_zilch(n_dice = 4, n_sims = 50000)\n```\n\n\n## Why even do this?\n\nBut we know the probability equation for getting at least a 1 or a 5, so why go through the hassle of making the computer roll millions of dice? Because we're not actually calculating the true probability of scoring every valid scoring combination! \n\nIn Zilch, you can score with at least a 1 or a 5, but you can also score with three-of-a-kind or three pairs or a 5-die straight. We could calculate the probability of rolling those and combine them with the probability of a 1 or a 5, but the formal equation will get really hairy and complicated. So instead, we can simulate.\n\n```{r}\nsimulate_zilch_full <- function(n_dice, n_sims) {\n  # Create empty variable with enough slots\n  did_something_score <- vector(\"logical\", n_sims)\n  \n  # Roll a bunch of dice a bunch of times\n  for (i in 1:n_sims) {\n    # Roll some dice\n    rolled_dice <- sample(1:6, n_dice, replace = TRUE)\n\n    # Check for 3 pairs separately since it's a complicated process\n    # If there are three different numbers...\n    if (length(table(rolled_dice)) == 3) {\n      # ...check if there are 3 pairs\n      three_pairs <- all(table(rolled_dice) == c(2, 2, 2))\n    } else {\n      three_pairs <- FALSE\n    }\n    \n    # Check if there's a scoring combination in there\n    did_it_happen <- 1 %in% rolled_dice |  # A 1\n      5 %in% rolled_dice |  # A 5\n      all(1:5 %in% rolled_dice) |  # A 1-5 straight\n      all(2:6 %in% rolled_dice) |  # A 2-6 straight\n      max(table(rolled_dice)) >= 3 |  # At least 3 of one number\n      three_pairs  # 3 pairs\n\n    # Store the result\n    did_something_score[i] <- did_it_happen\n  }\n  \n  # Find the proportion of TRUEs\n  sum(did_something_score) / n_sims\n}\n\nsix_dice <- simulate_zilch_full(6, 50000)\n```\n\nPhew! Now that we account for every possible scoring combination, there's a `r percent(six_dice, accuracy = 0.01)` chance of scoring *something* when rolling 6 dice. That's really high!\n\nFor fun, let's look at how that probability changes as the number of dice you roll decreases:\n\n```{r full-simluation, cache=TRUE}\nlibrary(tidyverse)\n\n# hoooo boy this is slow\nnumber_of_dice <- tibble(n_dice = 6:1) %>% \n  mutate(prob = map_dbl(n_dice, ~simulate_zilch_full(., 50000)))\n```\n\n```{r show-results}\nggplot(number_of_dice, aes(x = fct_rev(factor(n_dice)), y = prob)) +\n  geom_col() +\n  scale_y_continuous(labels = percent_format(accuracy = 1)) +\n  labs(x = \"Number of dice rolled\", y = \"Probability of scoring something\",\n       caption = \"Results over 50,000 simulations per count of dice\") +\n  theme_minimal()\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"highlight-style":"monokai","output-file":"zilch.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","bibliography":["../files/bib/references.bib"],"csl":"../files/bib/chicago-author-date.csl","description-meta":"Use modern statistical and data scientific tools to measure causal effects and evaluate public policy","_quarto-vars":{"author":"Andrew Weiss","instructor":{"name":"Dr. Jacob Wallace","name_no_title":"Jacob Wallace","email":"jacob.wallace@yale.edu","url":"https://www.jacobwswallace.com/home","twitter":"jwswallace","github":"jacobwittwallace","office":"60 College St","contact_policy":"E-mail and Slack are the best ways to get in contact with me. I will try to respond to all course-related e-mails and Slack messages within 24 hours (*really*), but also remember that life can be busy and chaotic for everyone (including me!), so if I don't respond right away, don't worry!","appointment_url":"https://calendly.com/andrewheiss/"},"course":{"number":"HPM 587","semester":"Spring 2024","days":"Thursdays","time":"4:30–7:00 PM","location":"Winslow Auditorium, LEPH","dates":"January–April 30, 2024","github":"https://github.com/jacobwittwallace","url":"https://kpratt02.github.io/","copyright_year":"2022","slack":"https://gsuevalf2022.slack.com"},"university":{"name":"Yale University","url":"https://www.yale.edu"},"school":{"name":"Yale School of Public Health","url":"https://ysph.yale.edu/"}},"theme":["litera","../html/custom.scss"],"title":"Zilch and simulations"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}